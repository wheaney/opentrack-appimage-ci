name: Build OpenTrack AppImage

on:
  # Manual trigger
  workflow_dispatch:
    inputs:
      opentrack_version:
        description: 'OpenTrack version to build (e.g., opentrack-2.3.14)'
        required: false
        default: 'latest'
  
  # Scheduled check for new releases (daily at 6 AM UTC)
  schedule:
    - cron: '0 6 * * *'
  
  # Allow running on push for testing
  push:
    branches: [ main ]
    paths:
      - '.github/workflows/build-appimage.yml'
      - 'build-scripts/**'

jobs:
  check-version:
    runs-on: ubuntu-latest
    outputs:
      should_build: ${{ steps.check.outputs.should_build }}
      opentrack_version: ${{ steps.check.outputs.version }}
      opentrack_tag: ${{ steps.check.outputs.tag }}
    steps:
      - name: Check latest OpenTrack release
        id: check
        run: |
          set -euo pipefail

          github_api_get() {
            local url="$1"
            local auth_args=()

            # Prefer token to avoid rate limits.
            if [ -n "${GITHUB_TOKEN:-}" ]; then
              auth_args+=( -H "Authorization: Bearer ${GITHUB_TOKEN}" )
            fi

            curl -fsSL \
              --retry 5 \
              --retry-all-errors \
              --retry-delay 2 \
              -H 'Accept: application/vnd.github+json' \
              -H 'User-Agent: opentrack-appimage-ci' \
              "${auth_args[@]}" \
              "$url"
          }

          resolve_latest_tag() {
            local repo="$1"
            local url="https://api.github.com/repos/${repo}/releases/latest"
            local json tag msg

            json="$(github_api_get "$url")" || return 1
            tag="$(printf '%s' "$json" | jq -r '.tag_name // empty')"

            if [ -z "$tag" ] || [ "$tag" = "null" ]; then
              msg="$(printf '%s' "$json" | jq -r '.message // empty' 2>/dev/null || true)"
              echo "ERROR: GitHub API returned an empty tag_name for ${repo}." >&2
              if [ -n "$msg" ]; then
                echo "GitHub API message: $msg" >&2
              fi
              echo "Tip: ensure jq is available and consider setting GITHUB_TOKEN to avoid rate limits." >&2
              return 2
            fi

            printf '%s\n' "$tag"
          }

          # Get latest OpenTrack release tag (retry + fail-fast on null)
          LATEST_RELEASE="$(resolve_latest_tag opentrack/opentrack)"
          echo "Latest OpenTrack release: $LATEST_RELEASE"
          
          # Check if we've already built this version
          OUR_LATEST="$(github_api_get "https://api.github.com/repos/${{ github.repository }}/releases/latest" 2>/dev/null | jq -r '.tag_name // empty' || true)"
          if [ -z "$OUR_LATEST" ] || [ "$OUR_LATEST" = "null" ]; then
            OUR_LATEST="none"
          fi
          echo "Our latest release: $OUR_LATEST"
          
          # Manual override
          if [ "${{ github.event.inputs.opentrack_version }}" != "" ] && [ "${{ github.event.inputs.opentrack_version }}" != "latest" ]; then
            LATEST_RELEASE="${{ github.event.inputs.opentrack_version }}"
            echo "Manual override to: $LATEST_RELEASE"
            echo "should_build=true" >> $GITHUB_OUTPUT
          elif [ "$LATEST_RELEASE" != "$OUR_LATEST" ]; then
            echo "New version detected!"
            echo "should_build=true" >> $GITHUB_OUTPUT
          else
            echo "Already built latest version"
            echo "should_build=false" >> $GITHUB_OUTPUT
          fi
          
          echo "version=${LATEST_RELEASE#opentrack-}" >> $GITHUB_OUTPUT
          echo "tag=$LATEST_RELEASE" >> $GITHUB_OUTPUT
        env:
          # GitHub automatically provides this in Actions; used for higher API rate limits.
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  build:
    needs: check-version
    if: needs.check-version.outputs.should_build == 'true' || github.event_name == 'push'
    runs-on: ubuntu-24.04
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      - name: Set up build information
        id: build_info
        run: |
          VERSION="${{ needs.check-version.outputs.version }}"
          TAG="${{ needs.check-version.outputs.opentrack_tag }}"
          
          # Fallback for push events
          if [ -z "$VERSION" ]; then
            VERSION=$(curl -s https://api.github.com/repos/opentrack/opentrack/releases/latest | jq -r '.tag_name' | sed 's/opentrack-//')
            TAG="opentrack-${VERSION}"
          fi
          
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "tag=$TAG" >> $GITHUB_OUTPUT
          echo "Building OpenTrack $VERSION"
      
      - name: Install system dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            binutils \
            build-essential \
            cmake \
            git \
            libegl1-mesa-dev \
            libgl1-mesa-dev \
            libx11-dev \
            libx11-xcb-dev \
            libxcb1-dev \
            libxkbcommon-dev \
            libxkbcommon-x11-dev \
            patchelf \
            squashfs-tools \
            qt6-base-dev \
            qt6-base-dev-tools \
            qt6-base-private-dev \
            qt6-declarative-dev \
            qt6-declarative-dev-tools \
            qt6-l10n-tools \
            qt6-tools-dev \
            qt6-tools-dev-tools \
            libqt6svg6-dev \
            libopencv-dev \
            libproc2-dev \
            wget \
            file \
            desktop-file-utils \
            zsync
      
      - name: Download and install ONNX Runtime
        run: |
          ONNX_VERSION="1.23.2"
          wget -q https://github.com/microsoft/onnxruntime/releases/download/v${ONNX_VERSION}/onnxruntime-linux-x64-${ONNX_VERSION}.tgz
          tar xzf onnxruntime-linux-x64-${ONNX_VERSION}.tgz
          sudo cp -r onnxruntime-linux-x64-${ONNX_VERSION}/include/* /usr/local/include/
          sudo cp -r onnxruntime-linux-x64-${ONNX_VERSION}/lib/* /usr/local/lib/
          sudo ldconfig
          echo "ONNX Runtime installed:"
          ls -la /usr/local/lib/libonnxruntime*
      
      - name: Clone and build OpenTrack
        run: |
          set -euo pipefail
          git clone --depth 1 --branch ${{ steps.build_info.outputs.tag }} https://github.com/opentrack/opentrack.git
          cd opentrack
          
          mkdir build
          cd build
          
          cmake .. \
            -DCMAKE_BUILD_TYPE=Release \
            -DCMAKE_INSTALL_PREFIX=/usr \
            -DOPENTRACK_USERCONFIG=/dev/null \
            -DSDK_ENABLE_LIBEVDEV=OFF \
            -DSDK_WINE:BOOL=OFF \
            -DSDK_XPLANE:BOOL=OFF \
            -D__otr_compile_flags_set=TRUE \
            -DCMAKE_C_FLAGS="-ggdb -Wall -Wextra -Wpedantic" \
            -DCMAKE_CXX_FLAGS="-ggdb -Wall -Wextra -Wpedantic -fpermissive" \
            -DCMAKE_C_FLAGS_RELEASE="-O3 -DNDEBUG -march=x86-64-v2 -mtune=generic" \
            -DCMAKE_CXX_FLAGS_RELEASE="-O3 -DNDEBUG -march=x86-64-v2 -mtune=generic" \
            -DCMAKE_EXE_LINKER_FLAGS="-Wl,-z,x86-64-v2" \
            -DCMAKE_SHARED_LINKER_FLAGS="-Wl,-z,x86-64-v2" \
            -DCMAKE_MODULE_LINKER_FLAGS="-Wl,-z,x86-64-v2" \
            -DCMAKE_EXE_LINKER_FLAGS_RELEASE="-Wl,-z,x86-64-v2" \
            -DCMAKE_SHARED_LINKER_FLAGS_RELEASE="-Wl,-z,x86-64-v2" \
            -DCMAKE_MODULE_LINKER_FLAGS_RELEASE="-Wl,-z,x86-64-v2" \
            -DONNXRuntime_DIR=/usr/local

          echo "CMake cache SDK values:";
          grep -E '^SDK_(WINE|XPLANE):' CMakeCache.txt || true

          sdk_wine_val="$(grep -E '^SDK_WINE:' CMakeCache.txt | head -n1 | cut -d= -f2- | tr -d '\r')"
          case "$sdk_wine_val" in
            ''|0|OFF|FALSE|N|NO)
              :
              ;;
            *)
              echo "ERROR: SDK_WINE resolved to '$sdk_wine_val' in CMakeCache.txt; wineg++ would be required." >&2
              echo "Dumping related cache lines:" >&2
              grep -nE 'SDK_WINE|SDK_XPLANE|proto-wine|WINE' CMakeCache.txt || true
              exit 1
              ;;
          esac
          
          make -j$(nproc)
          
          # Install to temporary directory
          DESTDIR=$GITHUB_WORKSPACE/AppDir make install

          echo "Normalizing RPATH/RUNPATH inside AppDir (avoid host /usr/libexec leakage)..."
          fix_rpath() {
            local elf="$1"
            local rpath="$2"
            if [ -f "$elf" ]; then
              patchelf --set-rpath "$rpath" "$elf" 2>/dev/null || true
            fi
          }

          fix_rpath "$GITHUB_WORKSPACE/AppDir/usr/bin/opentrack" '$ORIGIN/../lib:$ORIGIN/../libexec/opentrack'

          if [ -d "$GITHUB_WORKSPACE/AppDir/usr/lib" ]; then
            while IFS= read -r -d '' f; do
              fix_rpath "$f" '$ORIGIN'
            done < <(find "$GITHUB_WORKSPACE/AppDir/usr/lib" -type f -name '*.so*' -print0 2>/dev/null || true)
          fi

          if [ -d "$GITHUB_WORKSPACE/AppDir/usr/libexec/opentrack" ]; then
            while IFS= read -r -d '' f; do
              fix_rpath "$f" '$ORIGIN:$ORIGIN/../lib'
            done < <(find "$GITHUB_WORKSPACE/AppDir/usr/libexec/opentrack" -type f -name '*.so*' -print0 2>/dev/null || true)
          fi

          # Some toolchains emit an overly strict GNU_PROPERTY_X86_ISA_1_NEEDED
          # note (x86-64-v4) that causes Steam Deck to refuse to run.
          # Removing this note restores compatibility.
          objcopy --remove-section .note.gnu.property "$GITHUB_WORKSPACE/AppDir/usr/bin/opentrack" || true
          if [ -d "$GITHUB_WORKSPACE/AppDir/usr/libexec/opentrack" ]; then
            find "$GITHUB_WORKSPACE/AppDir/usr/libexec/opentrack" -type f -name '*.so' -print0 \
              | xargs -0 -r -n 1 objcopy --remove-section .note.gnu.property || true
          fi
      
      - name: Download linuxdeploy
        run: |
          wget -q https://github.com/linuxdeploy/linuxdeploy/releases/download/continuous/linuxdeploy-x86_64.AppImage
          wget -q https://github.com/linuxdeploy/linuxdeploy-plugin-qt/releases/download/continuous/linuxdeploy-plugin-qt-x86_64.AppImage
          chmod +x linuxdeploy*.AppImage
      
      - name: Prepare AppDir
        run: |
          set -euo pipefail
          # Ensure proper directory structure
          mkdir -p AppDir/usr/lib

          # linuxdeploy resolves DT_NEEDED via standard library paths.
          # OpenTrack installs several private modules under usr/libexec/opentrack
          # which the main binary depends on. To help linuxdeploy find them, also
          # copy them into usr/lib (keep the originals in libexec).
          if [ -d AppDir/usr/libexec/opentrack ]; then
            cp -v AppDir/usr/libexec/opentrack/*.so* AppDir/usr/lib/ || true
          fi
          
          # Copy ONNX Runtime libraries
          cp -v /usr/local/lib/libonnxruntime.so* AppDir/usr/lib/

          # OpenTrack's neuralnet tracker loads /usr/libexec/opentrack/onnxruntime.so,
          # which expects libonnxruntime.so next to it via $ORIGIN.
          mkdir -p AppDir/usr/libexec/opentrack
          cp -v /usr/local/lib/libonnxruntime.so* AppDir/usr/libexec/opentrack/
          
          # Create desktop file if it doesn't exist
          if [ ! -f AppDir/usr/share/applications/opentrack.desktop ]; then
            mkdir -p AppDir/usr/share/applications
            cat > AppDir/usr/share/applications/opentrack.desktop << 'EOF'
          [Desktop Entry]
          Type=Application
          Name=OpenTrack
          GenericName=Head Tracking
          Comment=Head tracking software with neural network support
          Exec=opentrack
          Icon=opentrack
          Categories=Utility;Game;
          Terminal=false
          EOF
          fi
          
          # Find and copy icon
          ICON_PATH=""
          # First try: icons installed into the AppDir
          ICON_PATH="$(find AppDir/usr/share/icons AppDir/usr/share/pixmaps -type f \
            \( -iname 'opentrack.png' -o -iname 'opentrack.svg' -o -iname 'opentrack*.png' -o -iname 'opentrack*.svg' \) \
            2>/dev/null | head -n 1 || true)"

          # Fallback: icon in the cloned OpenTrack source tree
          if [ -z "$ICON_PATH" ] && [ -d opentrack ]; then
            ICON_PATH="$(find opentrack -type f \
              \( -iname 'opentrack.png' -o -iname 'opentrack.svg' -o -iname 'opentrack*.png' -o -iname 'opentrack*.svg' \) \
              2>/dev/null | head -n 1 || true)"
          fi

          if [ -n "$ICON_PATH" ]; then
            ext="${ICON_PATH##*.}"
            cp -v "$ICON_PATH" "AppDir/opentrack.${ext}"
            ln -sf "opentrack.${ext}" AppDir/.DirIcon
            echo "Using icon: $ICON_PATH"
          else
            echo "WARNING: Could not locate an opentrack icon in AppDir or source tree" >&2
          fi

          echo "Bundling OpenCV runtime libraries (dlopen modules depend on them)..."
          ldconfig -p | awk '/libopencv_.*\.so/{print $NF}' | sort -u \
            | xargs -r -n 1 cp -v -t AppDir/usr/lib/ || true

          echo "Bundling Qt6 runtime libraries to avoid host Qt mixing..."
          ldconfig -p | awk '/libQt6.*\.so/{print $NF}' | sort -u \
            | xargs -r -n 1 cp -v -t AppDir/usr/lib/ || true

          # Provide a deterministic AppRun that forces bundled libs/plugins.
          cat > AppDir/AppRun <<'EOF'
          #!/bin/sh
          set -eu

          APPDIR="$(dirname "$(readlink -f "$0")")"
          export APPDIR

          export PATH="$APPDIR/usr/bin${PATH:+:$PATH}"
          export LD_LIBRARY_PATH="$APPDIR/usr/lib:$APPDIR/usr/libexec/opentrack${LD_LIBRARY_PATH:+:$LD_LIBRARY_PATH}"
          export XDG_DATA_DIRS="$APPDIR/usr/share${XDG_DATA_DIRS:+:$XDG_DATA_DIRS}"

          # Prefer bundled Qt plugins if present.
          qt_plugin_path=""
          if [ -d "$APPDIR/usr/plugins" ]; then
            qt_plugin_path="$APPDIR/usr/plugins"
          fi
          if [ -d "$APPDIR/usr/lib/qt6/plugins" ]; then
            qt_plugin_path="$APPDIR/usr/lib/qt6/plugins${qt_plugin_path:+:$qt_plugin_path}"
          fi
          if [ -n "$qt_plugin_path" ]; then
            export QT_PLUGIN_PATH="$qt_plugin_path"
          fi

          # Some linuxdeploy-plugin-qt layouts use usr/qml.
          if [ -d "$APPDIR/usr/qml" ]; then
            export QML2_IMPORT_PATH="$APPDIR/usr/qml${QML2_IMPORT_PATH:+:$QML2_IMPORT_PATH}"
          fi

          exec "$APPDIR/usr/bin/opentrack" "$@"
          EOF
          chmod +x AppDir/AppRun
      
      - name: Build AppImage
        run: |
          set -euo pipefail
          # Avoid requiring FUSE on the runner when executing AppImages.
          export APPIMAGE_EXTRACT_AND_RUN=1
          export VERSION="${{ steps.build_info.outputs.version }}"

          # linuxdeploy-plugin-qt expects Qt tools like qmlimportscanner on PATH.
          export PATH="/usr/lib/qt6/bin:/usr/lib/x86_64-linux-gnu/qt6/bin:$PATH"

          # Help linuxdeploy resolve OpenTrack's private modules.
          export LD_LIBRARY_PATH="$GITHUB_WORKSPACE/AppDir/usr/lib:$GITHUB_WORKSPACE/AppDir/usr/libexec/opentrack${LD_LIBRARY_PATH:+:$LD_LIBRARY_PATH}"

          # Ensure linuxdeploy-plugin-qt uses Qt6's qmake.
          if command -v qmake6 >/dev/null 2>&1; then
            export QMAKE="$(command -v qmake6)"
          elif command -v qt6-qmake >/dev/null 2>&1; then
            export QMAKE="$(command -v qt6-qmake)"
          fi
          
          LINUXDEPLOY_LOG="$GITHUB_WORKSPACE/linuxdeploy.log"
          echo "Running linuxdeploy (logging to: $LINUXDEPLOY_LOG)"

          icon_args=()
          if [ -f AppDir/opentrack.png ]; then
            icon_args+=( --icon-file AppDir/opentrack.png )
          elif [ -f AppDir/opentrack.svg ]; then
            icon_args+=( --icon-file AppDir/opentrack.svg )
          fi

          if ! ./linuxdeploy-x86_64.AppImage \
            --appdir AppDir \
            --plugin qt \
            --output appimage \
            --desktop-file AppDir/usr/share/applications/opentrack.desktop \
            --executable AppDir/usr/bin/opentrack \
            "${icon_args[@]}" 2>&1 | tee "$LINUXDEPLOY_LOG"; then
            echo "" >&2
            echo "linuxdeploy failed. Last 200 log lines:" >&2
            tail -n 200 "$LINUXDEPLOY_LOG" >&2 || true
            echo "" >&2
            echo "Diagnostics:" >&2
            command -v mksquashfs >&2 && mksquashfs -version 2>&1 | head -n 5 >&2 || true
            command -v patchelf >&2 && patchelf --version 2>&1 | head -n 5 >&2 || true
            exit 1
          fi
          
          # Rename to include version and neural net info
          mv OpenTrack-*.AppImage OpenTrack-NeuralNet-${VERSION}-x86_64.AppImage
      
      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: OpenTrack-AppImage
          path: OpenTrack-*.AppImage
      
      - name: Create Release
        if: github.event_name == 'schedule' || github.event_name == 'workflow_dispatch'
        uses: softprops/action-gh-release@v1
        with:
          tag_name: opentrack-${{ steps.build_info.outputs.version }}
          name: OpenTrack ${{ steps.build_info.outputs.version }} (Neural Net CPU)
          body: |
            # OpenTrack AppImage with Neural Network Support (CPU)
            
            Built from [OpenTrack ${{ steps.build_info.outputs.tag }}](https://github.com/opentrack/opentrack/releases/tag/${{ steps.build_info.outputs.tag }})
            
            ## Features
            - ✅ ONNX Runtime CPU support for neural network tracking
            - ✅ All standard OpenTrack features
            - ✅ Portable - runs on most Linux distributions
            
            ## Usage
            ```bash
            chmod +x OpenTrack-NeuralNet-${{ steps.build_info.outputs.version }}-x86_64.AppImage
            ./OpenTrack-NeuralNet-${{ steps.build_info.outputs.version }}-x86_64.AppImage
            ```
            
            ## System Requirements
            - Linux x86_64
            - Webcam or other video input device
            - FUSE support (most distros have this by default)
            
            Built automatically on: ${{ github.run_id }}
          files: OpenTrack-*.AppImage
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
