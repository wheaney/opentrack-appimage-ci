name: Build OpenTrack AppImage

# Default token permissions (principle of least privilege).
permissions:
  contents: read

on:
  # Manual trigger
  workflow_dispatch:
    inputs:
      opentrack_version:
        description: 'OpenTrack version to build (e.g., opentrack-2.3.14)'
        required: false
        default: 'latest'
  
  # Scheduled check for new releases (daily at 6 AM UTC)
  schedule:
    - cron: '0 6 * * *'
  
  # Allow running on push for testing
  push:
    branches: [ main ]
    paths:
      - '.github/workflows/build-appimage.yml'
      - 'build-scripts/**'

jobs:
  check-version:
    runs-on: ubuntu-latest
    outputs:
      should_build: ${{ steps.check.outputs.should_build }}
      opentrack_version: ${{ steps.check.outputs.version }}
      opentrack_tag: ${{ steps.check.outputs.tag }}
    steps:
      - name: Check latest OpenTrack release
        id: check
        run: |
          set -euo pipefail

          github_api_get() {
            local url="$1"
            local auth_args=()

            # Prefer token to avoid rate limits.
            if [ -n "${GITHUB_TOKEN:-}" ]; then
              auth_args+=( -H "Authorization: Bearer ${GITHUB_TOKEN}" )
            fi

            curl -fsSL \
              --retry 5 \
              --retry-all-errors \
              --retry-delay 2 \
              -H 'Accept: application/vnd.github+json' \
              -H 'User-Agent: opentrack-appimage-ci' \
              "${auth_args[@]}" \
              "$url"
          }

          resolve_latest_tag() {
            local repo="$1"
            local url="https://api.github.com/repos/${repo}/releases/latest"
            local json tag msg

            json="$(github_api_get "$url")" || return 1
            tag="$(printf '%s' "$json" | jq -r '.tag_name // empty')"

            if [ -z "$tag" ] || [ "$tag" = "null" ]; then
              msg="$(printf '%s' "$json" | jq -r '.message // empty' 2>/dev/null || true)"
              echo "ERROR: GitHub API returned an empty tag_name for ${repo}." >&2
              if [ -n "$msg" ]; then
                echo "GitHub API message: $msg" >&2
              fi
              echo "Tip: ensure jq is available and consider setting GITHUB_TOKEN to avoid rate limits." >&2
              return 2
            fi

            printf '%s\n' "$tag"
          }

          # Get latest OpenTrack release tag (retry + fail-fast on null)
          LATEST_RELEASE="$(resolve_latest_tag opentrack/opentrack)"
          echo "Latest OpenTrack release: $LATEST_RELEASE"
          
          # Check if we've already built this version
          OUR_LATEST="$(github_api_get "https://api.github.com/repos/${{ github.repository }}/releases/latest" 2>/dev/null | jq -r '.tag_name // empty' || true)"
          if [ -z "$OUR_LATEST" ] || [ "$OUR_LATEST" = "null" ]; then
            OUR_LATEST="none"
          fi
          echo "Our latest release: $OUR_LATEST"
          
          # Manual override
          if [ "${{ github.event.inputs.opentrack_version }}" != "" ] && [ "${{ github.event.inputs.opentrack_version }}" != "latest" ]; then
            LATEST_RELEASE="${{ github.event.inputs.opentrack_version }}"
            echo "Manual override to: $LATEST_RELEASE"
            echo "should_build=true" >> $GITHUB_OUTPUT
          elif [ "$LATEST_RELEASE" != "$OUR_LATEST" ]; then
            echo "New version detected!"
            echo "should_build=true" >> $GITHUB_OUTPUT
          else
            echo "Already built latest version"
            echo "should_build=false" >> $GITHUB_OUTPUT
          fi
          
          echo "version=${LATEST_RELEASE#opentrack-}" >> $GITHUB_OUTPUT
          echo "tag=$LATEST_RELEASE" >> $GITHUB_OUTPUT
        env:
          # GitHub automatically provides this in Actions; used for higher API rate limits.
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  build:
    needs: check-version
    if: needs.check-version.outputs.should_build == 'true' || github.event_name == 'push'
    runs-on: ubuntu-24.04
    strategy:
      fail-fast: false
      matrix:
        include:
          - flavor: no-onnx
            artifact_suffix: NoONNX
            onnx_variant: none
            allow_fail: false
          - flavor: onnx-cpu
            artifact_suffix: ONNX-CPU
            onnx_variant: cpu
            allow_fail: false
          - flavor: onnx-gpu
            artifact_suffix: ONNX-GPU
            onnx_variant: gpu
            # GPU builds often require CUDA runtime libs present at build/package time.
            # Keep the pipeline green while iterating on CUDA deps.
            allow_fail: true
    continue-on-error: ${{ matrix.allow_fail }}
    name: Build (${{ matrix.flavor }})
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      - name: Set up build information
        id: build_info
        run: |
          VERSION="${{ needs.check-version.outputs.opentrack_version }}"
          TAG="${{ needs.check-version.outputs.opentrack_tag }}"
          
          # Fallback for push events
          if [ -z "$VERSION" ]; then
            VERSION=$(curl -s https://api.github.com/repos/opentrack/opentrack/releases/latest | jq -r '.tag_name' | sed 's/opentrack-//')
            TAG="opentrack-${VERSION}"
          fi
          
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "tag=$TAG" >> $GITHUB_OUTPUT
          echo "Building OpenTrack $VERSION"
      
      - name: Install system dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            binutils \
            build-essential \
            cmake \
            git \
            libegl1-mesa-dev \
            libgl1-mesa-dev \
            libx11-dev \
            libx11-xcb-dev \
            libxcb1-dev \
            libxkbcommon-dev \
            libxkbcommon-x11-dev \
            patchelf \
            squashfs-tools \
            qt6-base-dev \
            qt6-base-dev-tools \
            qt6-base-private-dev \
            qt6-declarative-dev \
            qt6-declarative-dev-tools \
            qt6-l10n-tools \
            qt6-tools-dev \
            qt6-tools-dev-tools \
            libqt6svg6-dev \
            libopencv-dev \
            libproc2-dev \
            wget \
            file \
            desktop-file-utils \
            zsync
      
      - name: Download and install ONNX Runtime
        if: matrix.onnx_variant != 'none'
        run: |
          ONNX_VERSION="1.23.2"

          PKG="onnxruntime-linux-x64-${ONNX_VERSION}"
          if [ "${{ matrix.onnx_variant }}" = "gpu" ]; then
            # Note: this archive typically depends on system CUDA runtime libs.
            PKG="onnxruntime-linux-x64-gpu-${ONNX_VERSION}"
          fi

          wget -q "https://github.com/microsoft/onnxruntime/releases/download/v${ONNX_VERSION}/${PKG}.tgz"
          tar xzf "${PKG}.tgz"

          sudo cp -r "${PKG}/include/"* /usr/local/include/
          sudo cp -r "${PKG}/lib/"* /usr/local/lib/
          sudo ldconfig
          echo "ONNX Runtime installed:"
          ls -la /usr/local/lib/libonnxruntime*
      
      - name: Clone and build OpenTrack
        run: |
          set -euo pipefail
          git clone --depth 1 --branch ${{ steps.build_info.outputs.tag }} https://github.com/opentrack/opentrack.git
          cd opentrack
          
          mkdir build
          cd build

          cmake_args=(
            -DCMAKE_BUILD_TYPE=Release
            -DCMAKE_INSTALL_PREFIX=/usr
            -DOPENTRACK_USERCONFIG=/dev/null
            -DSDK_ENABLE_LIBEVDEV=OFF
            -DSDK_WINE:BOOL=OFF
            -DSDK_XPLANE:BOOL=OFF
            -D__otr_compile_flags_set=TRUE
            -DCMAKE_C_FLAGS="-ggdb -Wall -Wextra -Wpedantic"
            -DCMAKE_CXX_FLAGS="-ggdb -Wall -Wextra -Wpedantic -fpermissive"
            -DCMAKE_C_FLAGS_RELEASE="-O3 -DNDEBUG -march=x86-64-v2 -mtune=generic"
            -DCMAKE_CXX_FLAGS_RELEASE="-O3 -DNDEBUG -march=x86-64-v2 -mtune=generic"
            -DCMAKE_EXE_LINKER_FLAGS=-Wl,-z,x86-64-v2
            -DCMAKE_SHARED_LINKER_FLAGS=-Wl,-z,x86-64-v2
            -DCMAKE_MODULE_LINKER_FLAGS=-Wl,-z,x86-64-v2
            -DCMAKE_EXE_LINKER_FLAGS_RELEASE=-Wl,-z,x86-64-v2
            -DCMAKE_SHARED_LINKER_FLAGS_RELEASE=-Wl,-z,x86-64-v2
            -DCMAKE_MODULE_LINKER_FLAGS_RELEASE=-Wl,-z,x86-64-v2
          )

          if [ "${{ matrix.onnx_variant }}" != "none" ]; then
            cmake_args+=( -DONNXRuntime_DIR=/usr/local )
          fi

          cmake .. "${cmake_args[@]}"

          echo "CMake cache SDK values:";
          grep -E '^SDK_(WINE|XPLANE):' CMakeCache.txt || true

          sdk_wine_val="$(grep -E '^SDK_WINE:' CMakeCache.txt | head -n1 | cut -d= -f2- | tr -d '\r')"
          case "$sdk_wine_val" in
            ''|0|OFF|FALSE|N|NO)
              :
              ;;
            *)
              echo "ERROR: SDK_WINE resolved to '$sdk_wine_val' in CMakeCache.txt; wineg++ would be required." >&2
              echo "Dumping related cache lines:" >&2
              grep -nE 'SDK_WINE|SDK_XPLANE|proto-wine|WINE' CMakeCache.txt || true
              exit 1
              ;;
          esac
          
          make -j$(nproc)
          
          # Install to temporary directory
          DESTDIR=$GITHUB_WORKSPACE/AppDir make install

          echo "Normalizing RPATH/RUNPATH inside AppDir (avoid host /usr/libexec leakage)..."
          fix_rpath() {
            local elf="$1"
            local rpath="$2"
            if [ -f "$elf" ]; then
              patchelf --set-rpath "$rpath" "$elf" 2>/dev/null || true
            fi
          }

          fix_rpath "$GITHUB_WORKSPACE/AppDir/usr/bin/opentrack" '$ORIGIN/../lib:$ORIGIN/../libexec/opentrack'

          if [ -d "$GITHUB_WORKSPACE/AppDir/usr/lib" ]; then
            while IFS= read -r -d '' f; do
              fix_rpath "$f" '$ORIGIN'
            done < <(find "$GITHUB_WORKSPACE/AppDir/usr/lib" -type f -name '*.so*' -print0 2>/dev/null || true)
          fi

          if [ -d "$GITHUB_WORKSPACE/AppDir/usr/libexec/opentrack" ]; then
            while IFS= read -r -d '' f; do
              fix_rpath "$f" '$ORIGIN:$ORIGIN/../lib'
            done < <(find "$GITHUB_WORKSPACE/AppDir/usr/libexec/opentrack" -type f -name '*.so*' -print0 2>/dev/null || true)
          fi

          # Some toolchains emit an overly strict GNU_PROPERTY_X86_ISA_1_NEEDED
          # note (x86-64-v4) that causes Steam Deck to refuse to run.
          # Removing this note restores compatibility.
          objcopy --remove-section .note.gnu.property "$GITHUB_WORKSPACE/AppDir/usr/bin/opentrack" || true
          if [ -d "$GITHUB_WORKSPACE/AppDir/usr/libexec/opentrack" ]; then
            find "$GITHUB_WORKSPACE/AppDir/usr/libexec/opentrack" -type f -name '*.so' -print0 \
              | xargs -0 -r -n 1 objcopy --remove-section .note.gnu.property || true
          fi
      
      - name: Download linuxdeploy
        run: |
          wget -q https://github.com/linuxdeploy/linuxdeploy/releases/download/continuous/linuxdeploy-x86_64.AppImage
          wget -q https://github.com/linuxdeploy/linuxdeploy-plugin-qt/releases/download/continuous/linuxdeploy-plugin-qt-x86_64.AppImage
          wget -q https://github.com/AppImage/AppImageKit/releases/download/continuous/appimagetool-x86_64.AppImage
          chmod +x linuxdeploy*.AppImage
          chmod +x appimagetool-x86_64.AppImage
      
      - name: Prepare AppDir
        run: |
          set -euo pipefail
          # Ensure proper directory structure
          mkdir -p AppDir/usr/lib

          # linuxdeploy resolves DT_NEEDED via standard library paths.
          # OpenTrack installs several private modules under usr/libexec/opentrack
          # which the main binary depends on. To help linuxdeploy find them, also
          # copy them into usr/lib (keep the originals in libexec).
          if [ -d AppDir/usr/libexec/opentrack ]; then
            cp -v AppDir/usr/libexec/opentrack/*.so* AppDir/usr/lib/ || true
          fi

          if [ "${{ matrix.onnx_variant }}" != "none" ]; then
            # Copy ONNX Runtime libraries
            cp -v /usr/local/lib/libonnxruntime.so* AppDir/usr/lib/

            # OpenTrack's neuralnet tracker loads /usr/libexec/opentrack/onnxruntime.so,
            # which expects libonnxruntime.so next to it via $ORIGIN.
            mkdir -p AppDir/usr/libexec/opentrack
            cp -v /usr/local/lib/libonnxruntime.so* AppDir/usr/libexec/opentrack/

            # GPU builds commonly include extra ONNX Runtime provider libs.
            # Note: linuxdeploy will try to resolve their CUDA DT_NEEDED deps
            # (e.g., libcublasLt.so.12) and fail on GitHub-hosted runners.
            # Workaround: stash provider libs for GPU builds and copy them into
            # AppDir only after linuxdeploy has finished deploying deps.
            if [ "${{ matrix.onnx_variant }}" = "gpu" ]; then
              mkdir -p "$GITHUB_WORKSPACE/onnx_provider_stash"
              cp -v /usr/local/lib/libonnxruntime_providers_*.so* "$GITHUB_WORKSPACE/onnx_provider_stash/" 2>/dev/null || true
              echo "Stashed ONNX provider libs (GPU) for post-linuxdeploy packaging."
            else
              cp -v /usr/local/lib/libonnxruntime_providers_*.so* AppDir/usr/lib/ 2>/dev/null || true
              cp -v /usr/local/lib/libonnxruntime_providers_*.so* AppDir/usr/libexec/opentrack/ 2>/dev/null || true
            fi
          fi
          
          # Create desktop file if it doesn't exist
          if [ ! -f AppDir/usr/share/applications/opentrack.desktop ]; then
            mkdir -p AppDir/usr/share/applications
            cat > AppDir/usr/share/applications/opentrack.desktop << 'EOF'
          [Desktop Entry]
          Type=Application
          Name=OpenTrack
          GenericName=Head Tracking
          Comment=Head tracking software with neural network support
          Exec=opentrack
          Icon=opentrack
          Categories=Utility;Game;
          Terminal=false
          EOF
          fi
          
          # Find and copy icon
          ICON_PATH=""
          # First try: icons installed into the AppDir
          ICON_PATH="$(find AppDir/usr/share/icons AppDir/usr/share/pixmaps -type f \
            \( -iname 'opentrack.png' -o -iname 'opentrack.svg' -o -iname 'opentrack*.png' -o -iname 'opentrack*.svg' \) \
            2>/dev/null | head -n 1 || true)"

          # Fallback: icon in the cloned OpenTrack source tree
          if [ -z "$ICON_PATH" ] && [ -d opentrack ]; then
            ICON_PATH="$(find opentrack -type f \
              \( -iname 'opentrack.png' -o -iname 'opentrack.svg' -o -iname 'opentrack*.png' -o -iname 'opentrack*.svg' \) \
              2>/dev/null | head -n 1 || true)"
          fi

          if [ -n "$ICON_PATH" ]; then
            ext="${ICON_PATH##*.}"
            cp -v "$ICON_PATH" "AppDir/opentrack.${ext}"
            ln -sf "opentrack.${ext}" AppDir/.DirIcon
            echo "Using icon: $ICON_PATH"
          else
            echo "WARNING: Could not locate an opentrack icon in AppDir or source tree" >&2
          fi

          echo "Bundling OpenCV runtime libraries (dlopen modules depend on them)..."
          ldconfig -p | awk '/libopencv_.*\.so/{print $NF}' | sort -u \
            | xargs -r -n 1 cp -v -t AppDir/usr/lib/ || true

          echo "Bundling Qt6 runtime libraries to avoid host Qt mixing..."
          ldconfig -p | awk '/libQt6.*\.so/{print $NF}' | sort -u \
            | xargs -r -n 1 cp -v -t AppDir/usr/lib/ || true

          echo "Bundling OpenGL (GLVND) dispatcher libraries for portability..."
          # Some minimal Ubuntu installs don't include libopengl0 by default.
          # Bundling these dispatch libs is generally safe: they still use the host
          # vendor GL implementation underneath (NVIDIA/Mesa) via GLVND.
          ldconfig -p | awk '/\/libOpenGL\.so\.0$/{print $NF}' | head -n 1 \
            | xargs -r -n 1 cp -v -t AppDir/usr/lib/ || true
          ldconfig -p | awk '/\/libGLX\.so\.0$/{print $NF}' | head -n 1 \
            | xargs -r -n 1 cp -v -t AppDir/usr/lib/ || true
          ldconfig -p | awk '/\/libGLdispatch\.so\.0$/{print $NF}' | head -n 1 \
            | xargs -r -n 1 cp -v -t AppDir/usr/lib/ || true
          ldconfig -p | awk '/\/libEGL\.so\.1$/{print $NF}' | head -n 1 \
            | xargs -r -n 1 cp -v -t AppDir/usr/lib/ || true

          # Provide a deterministic AppRun that forces bundled libs/plugins.
          cat > AppDir/AppRun <<'EOF'
          #!/bin/sh
          set -eu

          APPDIR="$(dirname "$(readlink -f "$0")")"
          export APPDIR

          export PATH="$APPDIR/usr/bin${PATH:+:$PATH}"
          export LD_LIBRARY_PATH="$APPDIR/usr/lib:$APPDIR/usr/libexec/opentrack${LD_LIBRARY_PATH:+:$LD_LIBRARY_PATH}"
          export XDG_DATA_DIRS="$APPDIR/usr/share${XDG_DATA_DIRS:+:$XDG_DATA_DIRS}"

          # Prefer bundled Qt plugins if present.
          qt_plugin_path=""
          if [ -d "$APPDIR/usr/plugins" ]; then
            qt_plugin_path="$APPDIR/usr/plugins"
          fi
          if [ -d "$APPDIR/usr/lib/qt6/plugins" ]; then
            qt_plugin_path="$APPDIR/usr/lib/qt6/plugins${qt_plugin_path:+:$qt_plugin_path}"
          fi
          if [ -n "$qt_plugin_path" ]; then
            export QT_PLUGIN_PATH="$qt_plugin_path"
          fi

          # Some linuxdeploy-plugin-qt layouts use usr/qml.
          if [ -d "$APPDIR/usr/qml" ]; then
            export QML2_IMPORT_PATH="$APPDIR/usr/qml${QML2_IMPORT_PATH:+:$QML2_IMPORT_PATH}"
          fi

          exec "$APPDIR/usr/bin/opentrack" "$@"
          EOF
          chmod +x AppDir/AppRun

      - name: GPU diagnostics (CUDA deps)
        if: matrix.onnx_variant == 'gpu'
        run: |
          set -euo pipefail
          echo "=== ONNX Runtime GPU diagnostics ==="
          echo "Host libs in /usr/local/lib:" 
          ls -la /usr/local/lib/libonnxruntime*.so* || true
          echo

          echo "Provider libs (host):"
          ls -la /usr/local/lib/libonnxruntime_providers_*.so* 2>/dev/null || true
          echo

          for f in /usr/local/lib/libonnxruntime_providers_*.so*; do
            [ -e "$f" ] || continue
            echo "--- ldd: $f ---"
            ldd "$f" || true
            echo
          done

          echo "Provider libs (AppDir):"
          ls -la AppDir/usr/lib/libonnxruntime_providers_*.so* 2>/dev/null || true
          ls -la AppDir/usr/libexec/opentrack/libonnxruntime_providers_*.so* 2>/dev/null || true
          echo

          for f in AppDir/usr/lib/libonnxruntime_providers_*.so* AppDir/usr/libexec/opentrack/libonnxruntime_providers_*.so*; do
            [ -e "$f" ] || continue
            echo "--- ldd: $f ---"
            ldd "$f" || true
            echo
          done

          echo "If you see 'not found' above, the runner is missing CUDA/NVIDIA runtime libs (e.g. libcuda.so, libcudart.so, libcublas.so, libnvinfer.so)."
      
      - name: Build AppImage
        run: |
          set -euo pipefail
          # Avoid requiring FUSE on the runner when executing AppImages.
          export APPIMAGE_EXTRACT_AND_RUN=1
          export VERSION="${{ steps.build_info.outputs.version }}"

          # linuxdeploy-plugin-qt expects Qt tools like qmlimportscanner on PATH.
          export PATH="/usr/lib/qt6/bin:/usr/lib/x86_64-linux-gnu/qt6/bin:$PATH"

          # Help linuxdeploy resolve OpenTrack's private modules.
          export LD_LIBRARY_PATH="$GITHUB_WORKSPACE/AppDir/usr/lib:$GITHUB_WORKSPACE/AppDir/usr/libexec/opentrack${LD_LIBRARY_PATH:+:$LD_LIBRARY_PATH}"

          # Ensure linuxdeploy-plugin-qt uses Qt6's qmake.
          if command -v qmake6 >/dev/null 2>&1; then
            export QMAKE="$(command -v qmake6)"
          elif command -v qt6-qmake >/dev/null 2>&1; then
            export QMAKE="$(command -v qt6-qmake)"
          fi
          
          LINUXDEPLOY_LOG="$GITHUB_WORKSPACE/linuxdeploy.log"
          echo "Running linuxdeploy (logging to: $LINUXDEPLOY_LOG)"

          icon_args=()
          if [ -f AppDir/opentrack.png ]; then
            icon_args+=( --icon-file AppDir/opentrack.png )
          elif [ -f AppDir/opentrack.svg ]; then
            icon_args+=( --icon-file AppDir/opentrack.svg )
          fi

          exclude_args=()
          if [ "${{ matrix.onnx_variant }}" = "gpu" ]; then
            # GitHub-hosted runners do not ship CUDA/TensorRT runtime libs.
            # Exclude them from deployment so linuxdeploy can still produce an AppImage.
            # The resulting AppImage will require these libs to be available on the target system.
            exclude_args+=( --exclude-library 'libcuda.so*' )
            exclude_args+=( --exclude-library 'libcudart.so*' )
            exclude_args+=( --exclude-library 'libcublas.so*' )
            exclude_args+=( --exclude-library 'libcublasLt.so*' )
            exclude_args+=( --exclude-library 'libcufft.so*' )
            exclude_args+=( --exclude-library 'libcurand.so*' )
            exclude_args+=( --exclude-library 'libcudnn.so*' )
            exclude_args+=( --exclude-library 'libnvinfer.so*' )
            exclude_args+=( --exclude-library 'libnvonnxparser.so*' )
            exclude_args+=( --exclude-library 'libnvidia-ml.so*' )
          fi

          # For GPU builds, keep CUDA provider libs out of AppDir while running linuxdeploy,
          # then add them back and build the AppImage with appimagetool.
          if [ "${{ matrix.onnx_variant }}" = "gpu" ]; then
            if ! ./linuxdeploy-x86_64.AppImage \
              --appdir AppDir \
              --plugin qt \
              --desktop-file AppDir/usr/share/applications/opentrack.desktop \
              --executable AppDir/usr/bin/opentrack \
              --custom-apprun AppDir/AppRun \
              "${exclude_args[@]}" \
              "${icon_args[@]}" 2>&1 | tee "$LINUXDEPLOY_LOG"; then
              echo "" >&2
              echo "linuxdeploy failed. Last 200 log lines:" >&2
              tail -n 200 "$LINUXDEPLOY_LOG" >&2 || true
              echo "" >&2
              echo "Diagnostics:" >&2
              command -v mksquashfs >&2 && mksquashfs -version 2>&1 | head -n 5 >&2 || true
              command -v patchelf >&2 && patchelf --version 2>&1 | head -n 5 >&2 || true
              exit 1
            fi

            if [ -d "$GITHUB_WORKSPACE/onnx_provider_stash" ]; then
              echo "Copying stashed ONNX provider libs into AppDir (post-linuxdeploy)..."
              cp -v "$GITHUB_WORKSPACE"/onnx_provider_stash/libonnxruntime_providers_*.so* AppDir/usr/lib/ 2>/dev/null || true
              mkdir -p AppDir/usr/libexec/opentrack
              cp -v "$GITHUB_WORKSPACE"/onnx_provider_stash/libonnxruntime_providers_*.so* AppDir/usr/libexec/opentrack/ 2>/dev/null || true
            fi

            echo "Building AppImage with appimagetool (GPU flavor)..."
            ./appimagetool-x86_64.AppImage AppDir "OpenTrack-${{ matrix.artifact_suffix }}-${VERSION}-x86_64.AppImage"
          else
            if ! ./linuxdeploy-x86_64.AppImage \
              --appdir AppDir \
              --plugin qt \
              --output appimage \
              --desktop-file AppDir/usr/share/applications/opentrack.desktop \
              --executable AppDir/usr/bin/opentrack \
              --custom-apprun AppDir/AppRun \
              "${exclude_args[@]}" \
              "${icon_args[@]}" 2>&1 | tee "$LINUXDEPLOY_LOG"; then
              echo "" >&2
              echo "linuxdeploy failed. Last 200 log lines:" >&2
              tail -n 200 "$LINUXDEPLOY_LOG" >&2 || true
              echo "" >&2
              echo "Diagnostics:" >&2
              command -v mksquashfs >&2 && mksquashfs -version 2>&1 | head -n 5 >&2 || true
              command -v patchelf >&2 && patchelf --version 2>&1 | head -n 5 >&2 || true
              exit 1
            fi

            # Rename to include flavor + version
            mv OpenTrack-*.AppImage OpenTrack-${{ matrix.artifact_suffix }}-${VERSION}-x86_64.AppImage
          fi
      
      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: OpenTrack-${{ matrix.artifact_suffix }}
          path: OpenTrack-${{ matrix.artifact_suffix }}-*.AppImage

  release:
    needs: [check-version, build]
    # if: github.event_name == 'schedule' || github.event_name == 'workflow_dispatch'
    runs-on: ubuntu-latest
    permissions:
      contents: write
      actions: read
    steps:
      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: OpenTrack-*
          merge-multiple: true
          path: dist

      - name: Create or update Release (idempotent)
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail

          TAG="opentrack-${{ needs.check-version.outputs.opentrack_version }}"
          TITLE="OpenTrack ${{ needs.check-version.outputs.opentrack_version }} (AppImages)"
          NOTES_FILE="$RUNNER_TEMP/release-notes.md"

          cat > "$NOTES_FILE" <<'EOF'
          # OpenTrack AppImages

          Built from OpenTrack tag `${{ needs.check-version.outputs.opentrack_tag }}`.

          ## Flavors
          - `NoONNX`: OpenTrack without ONNX Runtime bundled
          - `ONNX-CPU`: ONNX Runtime CPU bundled for neuralnet tracker
          - `ONNX-GPU`: ONNX Runtime GPU bundled (requires system CUDA/NVIDIA runtime)

          ## Notes
          - `ONNX-GPU` may require additional CUDA runtime libraries on the target system.
          EOF

          if gh release view "$TAG" >/dev/null 2>&1; then
            echo "Release $TAG already exists; updating title/notes."
            gh release edit "$TAG" --title "$TITLE" --notes-file "$NOTES_FILE"
          else
            echo "Creating new release $TAG."
            gh release create "$TAG" --title "$TITLE" --notes-file "$NOTES_FILE" --target "$GITHUB_SHA"
          fi

          echo "Uploading artifacts to $TAG (clobber if they already exist)..."
          ls -la dist || true
          gh release upload "$TAG" dist/*.AppImage --clobber
